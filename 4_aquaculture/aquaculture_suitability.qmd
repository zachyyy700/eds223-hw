---
title: "Homework 4: Aquaculture Suitability Analysis"
author: "Zach Loo"
date: "November 13, 2025"
format: html
editor: source
execute:
  warning: false
  message: false
---

![](images/readme1.png) ![](images/readme2.png)

```{r}
# Load packages
library(terra)
library(tidyverse)
library(tmap)
library(kableExtra)
library(maptiles)
library(testthat)
library(sf)
```

## 1. Prepare data

```{r}
# Load sst data
sst_filelist <- list.files(path = here::here("data"), pattern = "average*")
sst_all <- terra::rast(here::here('data', sst_filelist)) |> 
  project("EPSG:4326")

# Rename layers
names(sst_all) <- c("2008", "2009", "2010", "2011", "2012")

# Display warning if sst stack not created correctly.
if (nlyr(sst_all) == 0) {
  warning("0 layers found. Re-do data loading")
}
```

```{r}
# Load depth & wc_regions data
depth_rast <- terra::rast(here::here('data', 'depth.tif')) |> 
  project("EPSG:4326")

wc_regions_sf <- st_read(here::here('data', 'wc_regions_clean.shp'), quiet = TRUE) |> 
  st_transform("EPSG:4326")
```

```{r}
# Use testthat to confirm CRSs match
test_that("Coordinate reference systems match", {
  expect_equal(crs(sst_all), crs(depth_rast))
  expect_equal(crs(depth_rast), crs(wc_regions_sf))
})
```

## 2. Process data

```{r}
# Find mean of sst_all layers
sst_avg <- terra::mean(sst_all)

# Convert to celsius
sst_avg_celsius <- sst_avg - 273.15
```

```{r}
# Handle resolution mismatch
if (res(depth_rast)[1] != res(sst_avg_celsius)[1]){
  print("Resolution mismatch. Resampling to match SST.")
  depth_rast <- resample(depth_rast, sst_avg_celsius, method = "near")
}
```

```{r}
# Use testthat to confirm resolution match
test_that("Resolutions match", {
  expect_equal(res(sst_avg_celsius), res(depth_rast))
})
```

```{r}
# Crop depth raster to sst extent
depth_cropped <- crop(depth_rast, sst_avg_celsius)

# Use testthat to confirm extents match
test_that("Extents match", {
  expect_equal(ext(sst_avg_celsius), ext(depth_cropped))
})
```

# 3. Find suitable locations

Oysters need the following conditions: 

- SST: 11-30°C

- Depth: 0-70m below sea level

```{r}
# Create matrix for SST reclassifying
rcl_sst <- matrix(c(-Inf, 11, 0,
                11, 30, 1,
                30, Inf, 0), ncol = 3, byrow = TRUE)

# Create matrix for depth reclassifying
rcl_depth <- matrix(c(-Inf, -70, 0,
                      -70, 0, 1,
                      0, Inf, 0), ncol = 3, byrow = TRUE)
```

```{r}
#| label: fig-sst-depth-suitable

# Use reclassification matrix to reclassify SST raster
sst_suitable <- classify(sst_avg_celsius, rcl = rcl_sst)

# Use reclassification matrix to reclassify depth raster
depth_suitable <- classify(depth_cropped, rcl = rcl_depth)
```

```{r}
# Multiply suitable SST & depth rasters to get combined suitable temp/depth raster
suitable_sst_depth <- sst_suitable * depth_suitable
# Change layer name
names(suitable_sst_depth) <- "suitable" # Cells are not sst mean anymore

# Assign values of 0 to NA
suitable_sst_depth[suitable_sst_depth == 0] <- NA
```

# 4. Determine the most suitable EEZ

```{r}
#| label: tbl-suitable-counts

# Calculate suitable raster cells in each polygon
region_counts <- terra::extract(suitable_sst_depth, wc_regions_sf, touches = TRUE) |> 
  group_by(ID) |> 
  summarise(count = sum(suitable, na.rm = TRUE)) |> 
  mutate(ID = wc_regions_sf$rgn)

kable(region_counts,
      col.names = c("Region", "Suitable Cell Count"),
      align = 'c')
```

**In EPSG:4326, cell size varies!!! Therefore the different cell sizes must be accounted for when calculating suitable area totals.**

```{r}
# Multiply suitable and cellsize rasters to get area per cell raster
area_raster <- suitable_sst_depth * cellSize(suitable_sst_depth, unit = 'km')
```

```{r}
#| label: tbl-suitable-area

# Calculate suitable areas area per region
region_areas <- terra::extract(area_raster, wc_regions_sf, touches = TRUE) |> 
  group_by(ID) |> 
  summarise(suitable_area = sum(suitable, na.rm = TRUE)) |> 
  mutate(ID = wc_regions_sf$rgn) |> 
  rename(rgn = ID)

kable(region_areas,
      col.names = c("Region", "Suitable Area (km<sup>2</sup>)"),
      digits = 2,
      align = 'c')
```

```{r}
# Join to vector regions
region_suitable_area <- left_join(x = wc_regions_sf, y = region_areas, by = "rgn") 
```

```{r fig.height=7}
#| label: fig-suitable-regions

tm_shape(region_suitable_area) +
  tm_basemap("CartoDB.VoyagerNoLabels") +
  tm_polygons(fill = "suitable_area", 
              fill.scale = tm_scale_continuous(values = "brewer.purples",
                                               ticks = seq(0, 4500, 1500)),
              fill.legend = tm_legend(title = expression(Suitable ~ Area ~ (km^{2})),
                                      position = c("right", "top"),
                                      reverse = TRUE)) +
  tm_text(text = "rgn", size = 0.7) +
  tm_title(text = "Oyster Aquaculture: West Coast US Regions") +
  tm_graticules(alpha = 0.2, lwd = 0.7) 
```

## 5. Create function

```{r}
find_suitable_areas <- function(species_name, min_temp, max_temp, min_depth, max_depth) {
  
  # Capitalize species name input for map title
  species_title <- species_name |> 
    str_to_title()
  
  # Create matrix for SST reclassifying
rcl_sst <- matrix(c(-Inf, min_temp, 0, 
                    min_temp, max_temp, 1, 
                    max_temp, Inf, 0), ncol = 3, byrow = TRUE)

# Create matrix for depth reclassifying
rcl_depth <- matrix(c(-Inf, min_depth, 0,
                      min_depth, max_depth, 1,
                      max_depth, Inf, 0), ncol = 3, byrow = TRUE)

# Use reclassification matrix to reclassify SST raster
sst_suitable <- classify(sst_avg_celsius, rcl = rcl_sst)

# Use reclassification matrix to reclassify depth raster
depth_suitable <- classify(depth_cropped, rcl = rcl_depth)

# Multiply suitable SST & depth rasters
suitable_sst_depth <- sst_suitable * depth_suitable
# Change layer name
names(suitable_sst_depth) <- "suitable" # Cells are not sst mean anymore

# Assign values of 0 to NA
suitable_sst_depth[suitable_sst_depth == 0] <- NA

# Multiply rasters
area_raster <- suitable_sst_depth * cellSize(suitable_sst_depth, unit = 'km')

# Calculate suitable areas area per region
region_areas <- terra::extract(area_raster, wc_regions_sf, touches = TRUE) |> 
  group_by(ID) |> 
  summarise(suitable_area = sum(suitable, na.rm = TRUE)) |> 
  mutate(ID = wc_regions_sf$rgn) |> 
  rename(rgn = ID)

# Join to vector regions
region_suitable_area <- left_join(x = wc_regions_sf, y = region_areas, by = "rgn")

tm_shape(region_suitable_area) +
  tm_basemap("CartoDB.VoyagerNoLabels") +
  tm_polygons(fill = "suitable_area", 
              fill.scale = tm_scale_continuous(values = "brewer.greens"),
              fill.legend = tm_legend(title = expression(Suitable ~ Area ~ (km^{2})),
                                      position = c("right", "top"),
                                      reverse = TRUE)) +
  tm_text(text = "rgn", size = 0.7) +
  tm_title(text = paste(species_title, "Aquaculture: West Coast US Regions")) +
  tm_graticules(alpha = 0.2, lwd = 0.7)
}
```

Rock scallop (*Crassadoma giganteum*)

- Depth range: 0 - 45m

- Temperature range: Temperate (13 - 22°C)

```{r fig.height=7}
#| label: fig-function
find_suitable_areas("Giant Rock Scallop", 13, 22, -45, 0)
```

